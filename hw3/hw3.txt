2. 
	s1: 1  
	s2: 
	  
	s1: 2 1 
	s2: 

	s1:
	s2: 2

	s1: 4 3
	s2: 2

	s1: 4 3
	s2:

	s1: 6 5 4 3
	s2:

3. 
a) 
	nlog(n).
	
	for (int i = 0; i < n; i ++)
	    if (A[i] == 0) {
	       for (int j = 1; j < n; j *= 2)
	          { /* do something that takes O(1) time */ }
	    }
	The inner for loop runs in log(n) time because
	it is a summation from k = 1 to log(n) of O(1).
	The outer for loop is a summation of log(n) from 0 to n,
	which equates to nlog(n) based on the definition of a 
	summation.

b)
	O(n^2(log(n)^2))

	int tally=0;
	for (int i = 1; i < n; i ++)
	{
	   for (int j = i; j < n; j ++)
	   {
	        if (j % i == 0)
	        {
	            for (int k = 1; k < n; k *= 2)
	            { 
	                tally++;
	            }
	        }
	   }
	}
	The inner most for loop runs in log(n) time because
	it is a summation from k = 1 to log(n) of O(1). However the loop
	only runs when j % i = 0. Notice the sequence of run times.
	n, n/2, n/3 ... 1 because i must be a factor of j. The summation of this
	sequence is from j = 1 to n - i -1 of O(log(n)) which equates to 
	O(n(log(n))^2). Then the outer for loop is a summation of O(n(log(n))^2) from
	i = 1 to n, which is equivalent to O(n^2(log(n)^2)).

c)
	O(n^2)

	int *a = new int [10];
	int size = 10;
	for (int i = 0; i < n; i ++) 
	{
	   if (i == size)
	   {  
	       int newsize = size+10;
	       int *b = new int [newsize];
	       for (int j = 0; j < size; j ++) b[j] = a[j];
	       delete [] a;
	       a = b;
	       size = newsize;
	   }
	   a[i] = sqrt(i);
	}

	The inner most for loop is a summation from j = 0 to size.
	Notice the size will always equal i because of the if block that
	encompasses the loop and that size is always a multiple of ten. For now,
	this for loop is a summation from j = 0 to i of O(1) which equals
	O(i). This is also accompanied by the other statements which sum up to 
	O(1) This loop will only run when i == size and size is a multiple of ten.
	So while the outer most for loop is a summation from i = 0
	to n - 1 of O(i) + O(1), it is actually a summation from i = 0 to n/10 of O(10i) 
	+ O(10). This equals O(n^2 + n) which is simplified to O(n^2).

d)
	O(n)

	int *a = new int [10];
	int size = 10;
	for (int i = 0; i < n; i ++) 
	{
	   if (i == size)
	   {  
	       int newsize = 2*size;
	       int *b = new int [newsize];
	       for (int j = 0; j < size; j ++) b[j] = a[j];
	       delete [] a;
	       a = b;
	       size = newsize;
	   }
	   a[i] = sqrt(i);
	}

	The inner most for loop is a summation from j = 0 to size.
	Notice the size will always equal i because of the if block that
	encompasses the loop and that size is always equal to 10 * 2^x where 
	x is between 0 and n. This summation is akin to O(log(i)) The outer most loop
	is a summation from i = 0 to n. The thing being summed is normally O(1) run 
	time but when i = size, it is O(log(i)) + O(1) run time. This happens when i =
	10 * 2^x and x is between 0 and n. We can rewrite this summation to be from i = 1 to
	log(n/10) of O(10*2^i) which is equal to the previous summation. We can reduce this to 
	be O(10*n/10) = O(n).